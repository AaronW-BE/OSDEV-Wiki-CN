# Getting Started


首先，开发一个操作系统可能是你在计算机上能做的最具挑战性的事情之一（仅次于在《毁灭战士》（Doom）的噩梦难度下击败最终Boss）。编写一个操作系统需要掌握计算机科学中多个复杂领域的大量知识。你需要了解硬件的工作原理，并能够读写复杂的汇编语言以及高级语言（如 C、C++ 或 [[Pascal]]）。你的思维必须能够理解抽象理论，并同时处理大量复杂的想法。感到气馁了吗？别害怕！因为正是这些挑战也让操作系统编程变得有趣和令人兴奋。

当你经过数小时的挣扎，终于解决问题时，那种成就感是无与伦比的。经过一段时间后，你可以回顾并看到自己从零开始创造的所有东西。你手写的系统能够启动，对硬件施展魔法，并为用户提供用户界面和可玩的程序。

在创建操作系统时，没有一条绝对的路径需要遵循。一旦你的初始系统启动并运行（你可以通过找到合适的教程来完成这一步），你就可以选择接下来要走的路。你的操作系统完全属于你——你拥有终极控制权，唯一限制你的只有你的想象力！

# 残酷的真相

希望操作系统开发是一个复杂且持续的过程这一基本事实不会让你感到气馁。事实是，操作系统开发确实是无与伦比的，因为它需要极大的耐心和谨慎的代码设计，而它带来的即时满足感却非常少，甚至没有——不像开发游戏或基于网络的脚本那样能快速看到成果。

我们已经明确警告了你前方的艰苦工作，但如果你仍然感兴趣，那就继续向前迈进，进入操作系统程序员的领域吧。准备好面对偶尔的困惑、挫折，以及对我们中的一些人来说……暂时的疯狂。只要有足够的时间和奉献精神，你会发现自己跻身于少数成功开发出可运行操作系统的精英之中。如果你在过程中感到气馁，可以重新阅读本书的内容。希望它能提醒你为什么一开始就踏上这条疯狂的旅程。

在这个阶段，阅读 [[初学者常见错误]] 页面会很有帮助。论坛上的用户注意到许多错误反复出现，避免这些错误是一个很好的方法，可以避免让自己显得很愚蠢。

# 责任

人们往往认为写低效的软件也没关系，因为如今的计算机系统速度很快，你不会注意到影响。这种心态在操作系统设计中是危险的。在开发简单应用时写一些粗糙的代码可能没问题，但当涉及到可能每秒被调用数千次的关键代码时，你需要尽可能去除所有开销。操作系统应该以最少的复杂性、抽象和开销，将计算机作为基本资源提供给运行的应用程序。

如今设计操作系统的人往往有“无所不包”的心态。他们觉得自己需要考虑所有事情，这当然是好的，但不应以允许低质量程序泛滥为代价。当程序出错时，“幕后”会发生很多事情。低质量的程序会浪费宝贵的执行时间，并涉及昂贵的任务切换，无论在内存还是频率上都代价高昂。我们鼓励你去阻止低质量软件的泛滥。

# 所需知识

**“如果你认为可以跳过这一部分，那它就是为你准备的。”**

本部分由于在论坛讨论中被频繁引用，已被 [[Required Knowledge | 移至单独页面]]。

# 组织你的计划

在继续之前，考虑一下你希望通过编写操作系统获得什么。你参与这个项目的动机是什么？参与一个业余操作系统项目可能有多种理由，大多数操作系统开发者有不止一个理由。即便只是说“我就是想做”也足够了，尽管你越是认真考虑和明确你的目标与动机，你就越能专注于你真正想要的东西。

也要对自己诚实。拥有更大的项目野心并不可耻，即使（或者特别是）这些野心不是主要目标。尝试承认你的所有目标，而不仅仅是你认为的主要目标。

试着确定你对操作系统设计中最感兴趣的部分，或者你认为需要重点关注的部分。操作系统开发早期，尤其是内核设计与开发，占据了大部分内容，但内核本身只是大多数操作系统的一小部分；如果你的主要兴趣在于用户体验、网络或驱动程序开发，你应该思考是否真的需要（现在或将来）编写自己的操作系统，或者在现有内核上开发这些东西是否也能让你满足。不少人因为想设计桌面环境而进入操作系统开发，所以这是一个非常重要的问题，需要问自己。

尝试考虑你可能想先做或同时做的非操作系统项目，尤其是那些可以作为操作系统项目练习或准备的项目。通常没有必要立刻开始操作系统项目，你提前准备得越多，未来的进展就会越顺利（当然，适度为宜——准备是一回事，拖延是另一回事）。

同样，如果你打算通过分叉现有设计来进行实验，或者为了特定目的修改它，那就专注于这部分，而不是一般的开发问题。考虑你需要的现有代码库部分，以及你想改变的部分。

尝试制定一些具体的项目目标，并准备好在必要时规划单独的项目。如果你的目标只是随便尝试，看看能做到什么，那也没问题；如果你的目标是推翻微软，那也可以（尽管可能不现实）。一旦你知道自己想做什么，就可以将细节分解成具体目标，并弄清楚实现它们需要什么。不要试图将太多互相矛盾的目标塞进一个项目——如果你有不同目标且彼此冲突，就将它们拆分成不同的项目。

如果可能的话，写下你计划的操作系统设计的概述，包括任何特定的要求或你认为值得注意的细节，或者能澄清你需要帮助的部分，并将其添加到你的公共存储库中。这不仅能让别人更容易帮助你，还能帮助你组织和稳定你的计划，就像为故事或论文写大纲一样。准备好随着目标和计划的变化维护它，但保留旧版本的副本（或者更好的是，将文档置于版本控制之下），这样你就能看到你的工作随时间的发展。

最后，审查项目所需的时间和资源，并决定它们是否可行。如果你知道自己只有有限的时间投入到项目中，就要考虑到这一点，无论如何，不要承诺一个外部截止日期，即使你确信自己能做到。操作系统开发需要时间——大量时间——试图在一个学期内完成一个完整的操作系统项目是不现实的。

# 选择你的开发环境

你需要一个平台来开发你的新系统。顺应通用计算的趋势，最受欢迎的是 GNU/Linux，但也有很多人使用 Windows。使用 GNU/Linux 系统的开发者在工具可用性上略有优势，但在 Windows 上也可以通过使用像 [[Cygwin]] 或 [[MinGW]] 这样的系统解决。

* Binutils：用于操作目标文件的基本工具。

* [[GCC]]：GNU 编译器集合。GCC 包含 C、C++、Fortran 和 Ada 等语言的编译器。

* [[Makefile|Make]]：用于自动化构建过程，当你有多个文件时会非常有用。

* Grep 和 sed：用于进行更强大的搜索和搜索替换（在填充数据表格时很有帮助）。

* Diffutils：对于显示两个文件之间的差异非常有用。

* [[Wikipedia:Perl|Perl]] 或 [[Wikipedia:Python_(programming_language)|Python]]：建议安装这两种脚本语言之一。它们在字符串处理等方面很有用。Perl 曾是推荐选择，但 Python 现在已经非常成熟，可能更容易学习。两者都有数百个可用的包/模块来完成各种任务。

* [[Which assembler should I use?(x86)|汇编器]]：例如 NASM 或 GAS。这取决于你的目标 CPU 架构。

* [[List of editors|编辑器]]：用于编写你的汇编、C 和其他（代码）文件。

你可能不会使用所有这些工具，但最好备着以防万一，并知道如何使用它们，即使只是基础使用。但如果你决定使用其他 [[Languages | 语言]]，那么工具的选择主要取决于你自己，上述列表可能对你没有任何帮助。以下信息主要与 C/C++ 或汇编开发者相关。

## GNU/Linux

最推荐的操作系统开发系统是 GNU/Linux。在使用 GNU/Linux 时，大多数 GNU 开发工具可能已经存在。如果没有，可以使用你的发行版包管理工具（APT、RPM、Portage、Pacman、Apk 等）按需安装。同样，制作一个 [[GCC Cross-Compiler | 交叉编译器]] 是必须的，以避免链接到开发系统的运行时文件。

常用编辑器包括 [[Wikipedia:Vim (text editor)|Vim]]、[[Wikipedia:Emacs|Emacs]]、[[Wikipedia:KDevelop|KDevelop]]、[[Wikipedia:Komodo_Edit|Komodo Edit]] 等。有些人更喜欢轻量级编辑器而不是 IDE，例如 [[Wikipedia:gedit|gedit]]、[[Wikipedia:Geany|Geany]] 和 [[Wikipedia:SciTE|SciTE]]。许多人喜欢 [[Wikipedia:Midnight_Commander|Midnight Commander]]，它有一个 [[Text UI]] 和内置编辑器（mcedit），因此非常轻量且速度极快。

关于使用哪个发行版，可以查看 [https://en.wikipedia.org/wiki/List_of_Linux_distributions Linux 发行版列表]。它们种类繁多，但只要是相对通用的发行版，应该都没问题。

如果你不确定，可以尝试 Ubuntu、Fedora 或 Linux Mint。

## Windows

为了获取必要的工具，你应该安装 [[Cygwin]] 环境。[[MinGW]] 或 [[DJGPP]] 是替代方案，但强烈建议使用 [https://www.msys2.org/ MSYS2]，因为它是最完整且兼容的环境，还包括一个包管理器来安装库和工具。

微软最近（截至撰写时）为 Windows 10 发布了一个可选功能 Windows Subsystem for Linux（WSL）。它基本上是一个运行在 Windows 上的真实 Ubuntu 命令行发行版，无需使用虚拟机。最新版本的 GCC 和 Binutils（截至撰写时为 6.1.0 和 2.27）在此环境中可以正确编译和工作。使用 Bash shell，你可以通过 /mnt/<驱动器字母> 访问你的 Windows 硬盘。这种解决方案的优点是，你可以同时使用所需的 Windows 或 Linux 工具，而无需确认它们是否在 Cygwin 中可用。许多必要的工具可以使用“apt-get”安装。

对于上述所有方案，强烈建议构建一个交叉编译器，不仅因为默认编译器针对不同的 [[Executable Formats|可执行文件格式]]，而且因为这通常是个好主意。查看 [[GCC Cross-Compiler]] 页面以获取详细信息和说明。

你还需要一个编辑器。使用记事本也可以，但如果有一个更完整的编辑器会更方便。例如，很多人使用 [http://notepad-plus-plus.org/ Notepad++] 或 [http://www.flos-freeware.ch/notepad2.html Notepad2]。如果你习惯 Unix 编辑器，可以从 Cygwin 提供的选项中选择一个（包括 Vim 和 Emacs，虽然需要适应，但非常强大）。

也可以使用 [[Visual Studio]]，或者免费下载的 [http://www.microsoft.com/express/ Visual C++ Express Edition]，来编写和编译你的操作系统。你需要一个特殊的配置文件，并且你会是少数派，但它确实工作得很好。你甚至可以在其上安装 Windows SDK，启用 64 位开发。唯一的缺点是它不支持内联汇编。

其他工具如 [[Watcom]] 或 [[Borland]] 也可以使用，但它们有各自的具体要求，且不常用于这类工作。

另一个需要考虑的是，你的目标可能是让你的操作系统实现自托管，即使用你的操作系统来编译你的操作系统。如果你的操作系统是用 C 编写的，你的最低要求将是一个 C 编译器和 C 库。如果你的操作系统目标是成为 Windows 克隆而不是另一个 POSIX 兼容的操作系统，你需要一个支持 Windows 调用的 C 库，而不是 POSIX 调用，以及一个仅使用该 C 库而不执行 POSIX 调用的 C 编译器。[http://pdos.org GCCWIN + PDPCLIB] 符合这个要求。

## MacOS

由于其底层使用 FreeBSD 的用户空间，MacOS 是完全 POSIX 兼容的。所有常用工具都可用（vi、bash、dd、cat、sed、tar、cpio 等）。几乎所有教程都可以开箱即用。缺少的工具主要是文件系统相关：没有 [[Loopback_Device|回环设备]]、没有 fdisk、没有 mkfs.vfat 或 mtools。但你可以使用 diskutil 来实现这些功能，或者使用 [https://brew.sh/ brew] 或 [https://www.macports.org/ macports] 安装这些缺失的工具。
要获取 gcc，在旧版本中，你可以在第二个安装 DVD 上找到一个 mpkg。新版 MacOS（10.13 及以上）可以通过在终端运行“xcode-select --install”来安装命令行版本的 XCode（不是 IDE，只是工具链）。这将安装 gcc、binutils 和 make。这个 gcc 实际上是一个伪装的 CLang，但功能足够强大，可以无问题地构建你自己的 [[GCC_Cross-Compiler|交叉编译器]]。建议使用官方编译器来引导 gcc，而不是从 brew 或 macports 安装一个。

# 测试你的操作系统

{{Main|Testing}}
上述文章深入探讨了如何选择测试你的操作系统以及如何将其与开发过程整合。讨论了物理和模拟测试环境。

# 保护你的代码

在构建代码的过程中，你将编写数百甚至数千行代码。你将花费无数小时，熬夜编码，而这时你真的应该去睡觉。你最不希望发生的就是磁盘崩溃，或者一个写得不好的“rm”或“format”命令毁掉你所有的工作。

你需要的是一个 [https://en.wikipedia.org/wiki/Version_control 版本控制系统]。[http://www.nongnu.org/cvs/ CVS] 已使用多年，但近年来面临 [http://subversion.apache.org/ Subversion]、[http://bazaar-vcs.org/ Bazaar]、[https://www.mercurial-scm.org// Mercurial] 和 [http://git-scm.com/ Git] 的激烈竞争。如果可能，你应该设置一个远程计算机或服务器作为版本控制服务器，但如果你没有这样的机器，也可以在本地开发计算机上托管版本控制系统。只是记得定期将你的代码备份到 CD 或通过 FTP。

我们不能过分强调这一点：如果你还没有使用源代码控制，你应该立即开始这样做。你只需要在代码中犯一次严重错误，就会意识到安全版本化和轻松恢复代码的重要性。虽然对于一个小型私人业余项目来说这可能看起来有些小题大做，但一旦你养成使用版本控制的习惯，你会奇怪自己之前是怎么没有它的。

对于 Git，你可以在 [https://github.com/ GitHub] 或 [https://bitbucket.org Bitbucket] 上创建你的项目。两者都提供免费的私有存储库。

在网络可访问的存储库上使用版本控制的另一个好处是，它让与他人协作和寻求帮助变得更容易。这在论坛中尤其有用，因为它可以避免不断在消息线程中发布更新的代码版本——你只需将对话指向你的存储库，线程中的其他人就能直接访问你最新的更改。如果随着项目的发展，你开始与其他开发者合作，这也是至关重要的（只是 [[Beginner Mistakes#Teamwork|不要指望这会一夜之间发生]]）。

# 常见起点

最简单的方式是使用 [[Limine Bare Bones]] 教程来启动一个“Hello World” 64 位 [[Higher Half Kernel|高半内核]]。另一种方法是学习计算机本身的启动过程，查看 [[Boot Sequence]] 页面。

还有许多其他 [[Tutorials]] 可用。

# 获取更多知识

如今，互联网上有大量关于操作系统开发的惊人知识，只需找到它们即可。首先，这里有这个 Wiki 本身。其中我们有许多 [[:Category:Tutorials|Tutorials]]。既然你已经在这里，你可能已经发现了它。这个网站上还有 [http://www.osdev.org/phpBB2/ 论坛]，许多开发者都在那里交流并可以帮助你（但请确保先阅读 [[How_To_Ask_Questions|如何提问]]）。已经出版了许多关于操作系统开发的书籍。其中一些在我们的 [[Books]] 页面上有特色介绍，更多内容可以在 [http://www.osdever.net/tutorials/ osdever.net] 上找到。

# 另见

## 文章
* [[:Category:Bare bones tutorials |Bare bones tutorials]]
* [[Resources]]
* [[What order should I make things in]]?

## 帖子

## 外部链接

* [http://www.osdever.net/ Bona Fide OS Development] 包含多个教程和文档。
* [http://www.informit.com/articles/article.aspx?p=26396 Implementing an Operating System] 作者：Andrew S. Tanenbaum。
* [[Category:OS Development]]

